{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport TouchableItem from \"./TouchableItem\";\nimport { SceneRendererPropType } from \"./PropTypes\";\nvar useNativeDriver = Boolean(NativeModules.NativeAnimatedModule);\n\nvar TabBar = function (_React$Component) {\n  _inherits(TabBar, _React$Component);\n\n  var _super = _createSuper(TabBar);\n\n  function TabBar(_props) {\n    var _this;\n\n    _classCallCheck(this, TabBar);\n\n    _this = _super.call(this, _props);\n    _this._isIntial = true;\n    _this._isManualScroll = false;\n    _this._isMomentumScroll = false;\n\n    _this._startTrackingPosition = function () {\n      _this._offsetXListener = _this.props.offsetX.addListener(function (_ref) {\n        var value = _ref.value;\n        _this._lastOffsetX = value;\n\n        _this._handlePosition();\n      });\n      _this._panXListener = _this.props.panX.addListener(function (_ref2) {\n        var value = _ref2.value;\n        _this._lastPanX = value;\n\n        _this._handlePosition();\n      });\n    };\n\n    _this._stopTrackingPosition = function () {\n      _this.props.offsetX.removeListener(_this._offsetXListener);\n\n      _this.props.panX.removeListener(_this._panXListener);\n    };\n\n    _this._handlePosition = function () {\n      var _this$props = _this.props,\n          navigationState = _this$props.navigationState,\n          layout = _this$props.layout;\n\n      if (layout.width === 0) {\n        return;\n      }\n\n      var panX = typeof _this._lastPanX === 'number' ? _this._lastPanX : 0;\n      var offsetX = typeof _this._lastOffsetX === 'number' ? _this._lastOffsetX : -navigationState.index * layout.width;\n      var value = (panX + offsetX) / -(layout.width || 0.001);\n\n      _this._adjustScroll(value);\n    };\n\n    _this._renderLabel = function (scene) {\n      if (typeof _this.props.renderLabel !== 'undefined') {\n        return _this.props.renderLabel(scene);\n      }\n\n      var label = _this.props.getLabelText(scene);\n\n      if (typeof label !== 'string') {\n        return null;\n      }\n\n      return React.createElement(Animated.Text, {\n        style: [styles.tabLabel, _this.props.labelStyle]\n      }, label);\n    };\n\n    _this._renderIndicator = function (props) {\n      if (typeof _this.props.renderIndicator !== 'undefined') {\n        return _this.props.renderIndicator(props);\n      }\n\n      var width = props.width,\n          position = props.position,\n          navigationState = props.navigationState;\n      var translateX = Animated.multiply(Animated.multiply(position.interpolate({\n        inputRange: [-1, navigationState.routes.length],\n        outputRange: [-1, navigationState.routes.length],\n        extrapolate: 'clamp'\n      }), width), I18nManager.isRTL ? -1 : 1);\n      return React.createElement(Animated.View, {\n        style: [styles.indicator, {\n          width: width,\n          transform: [{\n            translateX: translateX\n          }]\n        }, _this.props.indicatorStyle]\n      });\n    };\n\n    _this._getTabWidth = function (props) {\n      var layout = props.layout,\n          navigationState = props.navigationState,\n          tabStyle = props.tabStyle;\n      var flattened = StyleSheet.flatten(tabStyle);\n\n      if (flattened) {\n        switch (typeof flattened.width) {\n          case 'number':\n            return flattened.width;\n\n          case 'string':\n            if (flattened.width.endsWith('%')) {\n              var width = parseFloat(flattened.width);\n\n              if (Number.isFinite(width)) {\n                return layout.width * (width / 100);\n              }\n            }\n\n        }\n      }\n\n      if (props.scrollEnabled) {\n        return layout.width / 5 * 2;\n      }\n\n      return layout.width / navigationState.routes.length;\n    };\n\n    _this._handleTabPress = function (_ref3) {\n      var route = _ref3.route;\n      _this._pendingIndex = _this.props.navigationState.routes.indexOf(route);\n\n      if (_this.props.onTabPress) {\n        _this.props.onTabPress({\n          route: route\n        });\n      }\n\n      _this.props.jumpTo(route.key);\n    };\n\n    _this._handleTabLongPress = function (_ref4) {\n      var route = _ref4.route;\n\n      if (_this.props.onTabLongPress) {\n        _this.props.onTabLongPress({\n          route: route\n        });\n      }\n    };\n\n    _this._normalizeScrollValue = function (props, value) {\n      var layout = props.layout,\n          navigationState = props.navigationState;\n\n      var tabWidth = _this._getTabWidth(props);\n\n      var tabBarWidth = Math.max(tabWidth * navigationState.routes.length, layout.width);\n      var maxDistance = tabBarWidth - layout.width;\n      return Math.max(Math.min(value, maxDistance), 0);\n    };\n\n    _this._getScrollAmount = function (props, i) {\n      var layout = props.layout;\n\n      var tabWidth = _this._getTabWidth(props);\n\n      var centerDistance = tabWidth * (i + 1 / 2);\n      var scrollAmount = centerDistance - layout.width / 2;\n      return _this._normalizeScrollValue(props, scrollAmount);\n    };\n\n    _this._adjustScroll = function (value) {\n      if (_this.props.scrollEnabled) {\n        global.cancelAnimationFrame(_this._scrollResetCallback);\n        _this._scrollView && _this._scrollView.scrollTo({\n          x: _this._normalizeScrollValue(_this.props, _this._getScrollAmount(_this.props, value)),\n          animated: !_this._isIntial\n        });\n        _this._isIntial = false;\n      }\n    };\n\n    _this._resetScroll = function (value) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (_this.props.scrollEnabled) {\n        global.cancelAnimationFrame(_this._scrollResetCallback);\n        _this._scrollResetCallback = global.requestAnimationFrame(function () {\n          _this._scrollView && _this._scrollView.scrollTo({\n            x: _this._getScrollAmount(_this.props, value),\n            animated: animated\n          });\n        });\n      }\n    };\n\n    _this._handleBeginDrag = function () {\n      _this._isManualScroll = true;\n      _this._isMomentumScroll = false;\n    };\n\n    _this._handleEndDrag = function () {\n      global.requestAnimationFrame(function () {\n        if (_this._isMomentumScroll) {\n          return;\n        }\n\n        _this._isManualScroll = false;\n      });\n    };\n\n    _this._handleMomentumScrollBegin = function () {\n      _this._isMomentumScroll = true;\n    };\n\n    _this._handleMomentumScrollEnd = function () {\n      _this._isMomentumScroll = false;\n      _this._isManualScroll = false;\n    };\n\n    var initialVisibility = 1;\n\n    if (_this.props.scrollEnabled) {\n      var tabWidth = _this._getTabWidth(_this.props);\n\n      if (!tabWidth) {\n        initialVisibility = 0;\n      }\n    }\n\n    var initialOffset = _this.props.scrollEnabled && _this.props.layout.width ? {\n      x: _this._getScrollAmount(_this.props, _this.props.navigationState.index),\n      y: 0\n    } : undefined;\n    _this.state = {\n      visibility: new Animated.Value(initialVisibility),\n      scrollAmount: new Animated.Value(0),\n      initialOffset: initialOffset\n    };\n    return _this;\n  }\n\n  _createClass(TabBar, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.props.scrollEnabled && this._startTrackingPosition();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevTabWidth = this._getTabWidth(prevProps);\n\n      var currentTabWidth = this._getTabWidth(this.props);\n\n      var pendingIndex = typeof this._pendingIndex === 'number' ? this._pendingIndex : this.props.navigationState.index;\n      this._pendingIndex = null;\n\n      if (prevTabWidth !== currentTabWidth && currentTabWidth) {\n        this.state.visibility.setValue(1);\n      }\n\n      if (prevProps.navigationState.routes.length !== this.props.navigationState.routes.length || prevProps.layout.width !== this.props.layout.width) {\n        this._resetScroll(this.props.navigationState.index, false);\n      } else if (prevProps.navigationState.index !== pendingIndex) {\n        this._resetScroll(this.props.navigationState.index);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._stopTrackingPosition();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          position = _this$props2.position,\n          navigationState = _this$props2.navigationState,\n          scrollEnabled = _this$props2.scrollEnabled,\n          bounces = _this$props2.bounces;\n      var routes = navigationState.routes;\n\n      var tabWidth = this._getTabWidth(this.props);\n\n      var tabBarWidth = tabWidth * routes.length;\n      var inputRange = [-1].concat(_toConsumableArray(routes.map(function (x, i) {\n        return i;\n      })));\n      var translateX = Animated.multiply(this.state.scrollAmount, -1);\n      return React.createElement(Animated.View, {\n        style: [styles.tabBar, this.props.style]\n      }, React.createElement(Animated.View, {\n        pointerEvents: \"none\",\n        style: [styles.indicatorContainer, scrollEnabled ? {\n          width: tabBarWidth,\n          transform: [{\n            translateX: translateX\n          }]\n        } : null]\n      }, this._renderIndicator(_objectSpread(_objectSpread({}, this.props), {}, {\n        width: tabWidth\n      }))), React.createElement(View, {\n        style: styles.scroll\n      }, React.createElement(Animated.ScrollView, {\n        horizontal: true,\n        keyboardShouldPersistTaps: \"handled\",\n        scrollEnabled: scrollEnabled,\n        bounces: bounces,\n        alwaysBounceHorizontal: false,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        automaticallyAdjustContentInsets: false,\n        overScrollMode: \"never\",\n        contentContainerStyle: [styles.tabContent, scrollEnabled ? null : styles.container],\n        scrollEventThrottle: 1,\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: this.state.scrollAmount\n            }\n          }\n        }], {\n          useNativeDriver: useNativeDriver\n        }),\n        onScrollBeginDrag: this._handleBeginDrag,\n        onScrollEndDrag: this._handleEndDrag,\n        onMomentumScrollBegin: this._handleMomentumScrollBegin,\n        onMomentumScrollEnd: this._handleMomentumScrollEnd,\n        contentOffset: this.state.initialOffset,\n        ref: function ref(el) {\n          return _this2._scrollView = el && el.getNode();\n        }\n      }, routes.map(function (route, i) {\n        var outputRange = inputRange.map(function (inputIndex) {\n          return inputIndex === i ? 1 : 0.7;\n        });\n        var opacity = Animated.multiply(_this2.state.visibility, position.interpolate({\n          inputRange: inputRange,\n          outputRange: outputRange\n        }));\n\n        var label = _this2._renderLabel({\n          route: route\n        });\n\n        var icon = _this2.props.renderIcon ? _this2.props.renderIcon({\n          route: route\n        }) : null;\n        var badge = _this2.props.renderBadge ? _this2.props.renderBadge({\n          route: route\n        }) : null;\n        var tabStyle = {};\n        tabStyle.opacity = opacity;\n\n        if (icon) {\n          if (label) {\n            tabStyle.paddingTop = 8;\n          } else {\n            tabStyle.padding = 12;\n          }\n        }\n\n        var passedTabStyle = StyleSheet.flatten(_this2.props.tabStyle);\n        var isWidthSet = passedTabStyle && typeof passedTabStyle.width !== 'undefined' || scrollEnabled === true;\n        var tabContainerStyle = {};\n\n        if (isWidthSet) {\n          tabStyle.width = tabWidth;\n        }\n\n        if (passedTabStyle && typeof passedTabStyle.flex === 'number') {\n          tabContainerStyle.flex = passedTabStyle.flex;\n        } else if (!isWidthSet) {\n          tabContainerStyle.flex = 1;\n        }\n\n        var accessibilityLabel = _this2.props.getAccessibilityLabel({\n          route: route\n        });\n\n        accessibilityLabel = typeof accessibilityLabel !== 'undefined' ? accessibilityLabel : _this2.props.getLabelText({\n          route: route\n        });\n        var isFocused = i === navigationState.index;\n        return React.createElement(TouchableItem, {\n          borderless: true,\n          key: route.key,\n          testID: _this2.props.getTestID({\n            route: route\n          }),\n          accessible: _this2.props.getAccessible({\n            route: route\n          }),\n          accessibilityLabel: accessibilityLabel,\n          accessibilityTraits: isFocused ? ['button', 'selected'] : 'button',\n          accessibilityComponentType: \"button\",\n          accessibilityRole: \"button\",\n          accessibilityStates: isFocused ? ['selected'] : [],\n          pressColor: _this2.props.pressColor,\n          pressOpacity: _this2.props.pressOpacity,\n          delayPressIn: 0,\n          onPress: function onPress() {\n            return _this2._handleTabPress({\n              route: route\n            });\n          },\n          onLongPress: function onLongPress() {\n            return _this2._handleTabLongPress({\n              route: route\n            });\n          },\n          style: tabContainerStyle\n        }, React.createElement(View, {\n          pointerEvents: \"none\",\n          style: styles.container\n        }, React.createElement(Animated.View, {\n          style: [styles.tabItem, tabStyle, passedTabStyle, styles.container]\n        }, icon, label), badge ? React.createElement(Animated.View, {\n          style: [styles.badge, {\n            opacity: _this2.state.visibility\n          }]\n        }, badge) : null));\n      }))));\n    }\n  }]);\n\n  return TabBar;\n}(React.Component);\n\nTabBar.propTypes = _objectSpread(_objectSpread({}, SceneRendererPropType), {}, {\n  scrollEnabled: PropTypes.bool,\n  bounces: PropTypes.bool,\n  pressColor: TouchableItem.propTypes.pressColor,\n  pressOpacity: TouchableItem.propTypes.pressOpacity,\n  getLabelText: PropTypes.func,\n  getAccessible: PropTypes.func,\n  getAccessibilityLabel: PropTypes.func,\n  getTestID: PropTypes.func,\n  renderIcon: PropTypes.func,\n  renderLabel: PropTypes.func,\n  renderIndicator: PropTypes.func,\n  onTabPress: PropTypes.func,\n  onTabLongPress: PropTypes.func,\n  labelStyle: PropTypes.any,\n  style: PropTypes.any\n});\nTabBar.defaultProps = {\n  getLabelText: function getLabelText(_ref5) {\n    var route = _ref5.route;\n    return typeof route.title === 'string' ? route.title.toUpperCase() : route.title;\n  },\n  getAccessible: function getAccessible(_ref6) {\n    var route = _ref6.route;\n    return typeof route.accessible !== 'undefined' ? route.accessible : true;\n  },\n  getAccessibilityLabel: function getAccessibilityLabel(_ref7) {\n    var route = _ref7.route;\n    return route.accessibilityLabel;\n  },\n  getTestID: function getTestID(_ref8) {\n    var route = _ref8.route;\n    return route.testID;\n  }\n};\nexport { TabBar as default };\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.OS === 'web' ? 'auto' : 'scroll'\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth\n    },\n    zIndex: Platform.OS === 'android' ? 0 : 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  tabLabel: {\n    backgroundColor: 'transparent',\n    color: 'white',\n    margin: 8\n  },\n  tabItem: {\n    flex: 1,\n    padding: 8,\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  badge: {\n    position: 'absolute',\n    top: 0,\n    right: 0\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  },\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2\n  }\n});","map":{"version":3,"names":["React","PropTypes","TouchableItem","SceneRendererPropType","useNativeDriver","Boolean","NativeModules","NativeAnimatedModule","TabBar","props","_isIntial","_isManualScroll","_isMomentumScroll","_startTrackingPosition","_offsetXListener","offsetX","addListener","value","_lastOffsetX","_handlePosition","_panXListener","panX","_lastPanX","_stopTrackingPosition","removeListener","navigationState","layout","width","index","_adjustScroll","_renderLabel","scene","renderLabel","label","getLabelText","styles","tabLabel","labelStyle","_renderIndicator","renderIndicator","position","translateX","Animated","multiply","interpolate","inputRange","routes","length","outputRange","extrapolate","I18nManager","isRTL","indicator","transform","indicatorStyle","_getTabWidth","tabStyle","flattened","StyleSheet","flatten","endsWith","parseFloat","Number","isFinite","scrollEnabled","_handleTabPress","route","_pendingIndex","indexOf","onTabPress","jumpTo","key","_handleTabLongPress","onTabLongPress","_normalizeScrollValue","tabWidth","tabBarWidth","Math","max","maxDistance","min","_getScrollAmount","i","centerDistance","scrollAmount","global","cancelAnimationFrame","_scrollResetCallback","_scrollView","scrollTo","x","animated","_resetScroll","requestAnimationFrame","_handleBeginDrag","_handleEndDrag","_handleMomentumScrollBegin","_handleMomentumScrollEnd","initialVisibility","initialOffset","y","undefined","state","visibility","Value","prevProps","prevTabWidth","currentTabWidth","pendingIndex","setValue","bounces","map","tabBar","style","indicatorContainer","scroll","tabContent","container","event","nativeEvent","contentOffset","el","getNode","inputIndex","opacity","icon","renderIcon","badge","renderBadge","paddingTop","padding","passedTabStyle","isWidthSet","tabContainerStyle","flex","accessibilityLabel","getAccessibilityLabel","isFocused","getTestID","getAccessible","pressColor","pressOpacity","tabItem","Component","propTypes","bool","func","any","defaultProps","title","toUpperCase","accessible","testID","create","overflow","Platform","OS","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","height","zIndex","flexDirection","flexWrap","color","margin","alignItems","justifyContent","top","right","left","bottom"],"sources":["C:/Users/mike/Desktop/ha/DrawingKid_Expo_20210705/node_modules/react-native-tab-view/src/TabBar.js"],"sourcesContent":["/* @flow */\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Animated,\n  NativeModules,\n  StyleSheet,\n  View,\n  ScrollView,\n  Platform,\n  I18nManager,\n} from 'react-native';\nimport TouchableItem from './TouchableItem';\nimport { SceneRendererPropType } from './PropTypes';\nimport type { Scene, SceneRendererProps } from './TypeDefinitions';\nimport type {\n  ViewStyleProp,\n  TextStyleProp,\n} from 'react-native/Libraries/StyleSheet/StyleSheet';\n\ntype IndicatorProps<T> = SceneRendererProps<T> & {\n  width: number,\n};\n\ntype Props<T> = SceneRendererProps<T> & {\n  scrollEnabled?: boolean,\n  bounces?: boolean,\n  pressColor?: string,\n  pressOpacity?: number,\n  getLabelText: (scene: Scene<T>) => ?string,\n  getAccessible: (scene: Scene<T>) => ?boolean,\n  getAccessibilityLabel: (scene: Scene<T>) => ?string,\n  getTestID: (scene: Scene<T>) => ?string,\n  renderLabel?: (scene: Scene<T>) => React.Node,\n  renderIcon?: (scene: Scene<T>) => React.Node,\n  renderBadge?: (scene: Scene<T>) => React.Node,\n  renderIndicator?: (props: IndicatorProps<T>) => React.Node,\n  onTabPress?: (scene: Scene<T>) => mixed,\n  onTabLongPress?: (scene: Scene<T>) => mixed,\n  tabStyle?: ViewStyleProp,\n  indicatorStyle?: ViewStyleProp,\n  labelStyle?: TextStyleProp,\n  style?: ViewStyleProp,\n};\n\ntype State = {|\n  visibility: Animated.Value,\n  scrollAmount: Animated.Value,\n  initialOffset: ?{| x: number, y: number |},\n|};\n\nconst useNativeDriver = Boolean(NativeModules.NativeAnimatedModule);\n\nexport default class TabBar<T: *> extends React.Component<Props<T>, State> {\n  static propTypes = {\n    ...SceneRendererPropType,\n    scrollEnabled: PropTypes.bool,\n    bounces: PropTypes.bool,\n    pressColor: TouchableItem.propTypes.pressColor,\n    pressOpacity: TouchableItem.propTypes.pressOpacity,\n    getLabelText: PropTypes.func,\n    getAccessible: PropTypes.func,\n    getAccessibilityLabel: PropTypes.func,\n    getTestID: PropTypes.func,\n    renderIcon: PropTypes.func,\n    renderLabel: PropTypes.func,\n    renderIndicator: PropTypes.func,\n    onTabPress: PropTypes.func,\n    onTabLongPress: PropTypes.func,\n    labelStyle: PropTypes.any,\n    style: PropTypes.any,\n  };\n\n  static defaultProps = {\n    getLabelText: ({ route }: Scene<T>) =>\n      typeof route.title === 'string' ? route.title.toUpperCase() : route.title,\n    getAccessible: ({ route }: Scene<T>) =>\n      typeof route.accessible !== 'undefined' ? route.accessible : true,\n    getAccessibilityLabel: ({ route }: Scene<T>) => route.accessibilityLabel,\n    getTestID: ({ route }: Scene<T>) => route.testID,\n  };\n\n  constructor(props: Props<T>) {\n    super(props);\n\n    let initialVisibility = 1;\n\n    if (this.props.scrollEnabled) {\n      const tabWidth = this._getTabWidth(this.props);\n      if (!tabWidth) {\n        initialVisibility = 0;\n      }\n    }\n\n    const initialOffset =\n      this.props.scrollEnabled && this.props.layout.width\n        ? {\n            x: this._getScrollAmount(\n              this.props,\n              this.props.navigationState.index\n            ),\n            y: 0,\n          }\n        : undefined;\n\n    this.state = {\n      visibility: new Animated.Value(initialVisibility),\n      scrollAmount: new Animated.Value(0),\n      initialOffset,\n    };\n  }\n\n  componentDidMount() {\n    this.props.scrollEnabled && this._startTrackingPosition();\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const prevTabWidth = this._getTabWidth(prevProps);\n    const currentTabWidth = this._getTabWidth(this.props);\n    const pendingIndex =\n      typeof this._pendingIndex === 'number'\n        ? this._pendingIndex\n        : this.props.navigationState.index;\n\n    this._pendingIndex = null;\n\n    if (prevTabWidth !== currentTabWidth && currentTabWidth) {\n      this.state.visibility.setValue(1);\n    }\n\n    if (\n      prevProps.navigationState.routes.length !==\n        this.props.navigationState.routes.length ||\n      prevProps.layout.width !== this.props.layout.width\n    ) {\n      this._resetScroll(this.props.navigationState.index, false);\n    } else if (prevProps.navigationState.index !== pendingIndex) {\n      this._resetScroll(this.props.navigationState.index);\n    }\n  }\n\n  componentWillUnmount() {\n    this._stopTrackingPosition();\n  }\n\n  _scrollView: ?ScrollView;\n  _isIntial: boolean = true;\n  _isManualScroll: boolean = false;\n  _isMomentumScroll: boolean = false;\n  _pendingIndex: ?number;\n  _scrollResetCallback: any;\n  _lastPanX: ?number;\n  _lastOffsetX: ?number;\n  _panXListener: string;\n  _offsetXListener: string;\n\n  _startTrackingPosition = () => {\n    this._offsetXListener = this.props.offsetX.addListener(({ value }) => {\n      this._lastOffsetX = value;\n      this._handlePosition();\n    });\n    this._panXListener = this.props.panX.addListener(({ value }) => {\n      this._lastPanX = value;\n      this._handlePosition();\n    });\n  };\n\n  _stopTrackingPosition = () => {\n    this.props.offsetX.removeListener(this._offsetXListener);\n    this.props.panX.removeListener(this._panXListener);\n  };\n\n  _handlePosition = () => {\n    const { navigationState, layout } = this.props;\n\n    if (layout.width === 0) {\n      // Don't do anything if we don't have layout yet\n      return;\n    }\n\n    const panX = typeof this._lastPanX === 'number' ? this._lastPanX : 0;\n    const offsetX =\n      typeof this._lastOffsetX === 'number'\n        ? this._lastOffsetX\n        : -navigationState.index * layout.width;\n\n    const value = (panX + offsetX) / -(layout.width || 0.001);\n\n    this._adjustScroll(value);\n  };\n\n  _renderLabel = (scene: Scene<*>) => {\n    if (typeof this.props.renderLabel !== 'undefined') {\n      return this.props.renderLabel(scene);\n    }\n    const label = this.props.getLabelText(scene);\n    if (typeof label !== 'string') {\n      return null;\n    }\n    return (\n      <Animated.Text style={[styles.tabLabel, this.props.labelStyle]}>\n        {label}\n      </Animated.Text>\n    );\n  };\n\n  _renderIndicator = (props: IndicatorProps<T>) => {\n    if (typeof this.props.renderIndicator !== 'undefined') {\n      return this.props.renderIndicator(props);\n    }\n    const { width, position, navigationState } = props;\n    const translateX = Animated.multiply(\n      Animated.multiply(\n        position.interpolate({\n          inputRange: [-1, navigationState.routes.length],\n          outputRange: [-1, navigationState.routes.length],\n          extrapolate: 'clamp',\n        }),\n        width\n      ),\n      I18nManager.isRTL ? -1 : 1\n    );\n    return (\n      <Animated.View\n        style={[\n          styles.indicator,\n          { width, transform: [{ translateX }] },\n          this.props.indicatorStyle,\n        ]}\n      />\n    );\n  };\n\n  _getTabWidth = props => {\n    const { layout, navigationState, tabStyle } = props;\n    const flattened = StyleSheet.flatten(tabStyle);\n\n    if (flattened) {\n      switch (typeof flattened.width) {\n        case 'number':\n          return flattened.width;\n        case 'string':\n          if (flattened.width.endsWith('%')) {\n            const width = parseFloat(flattened.width);\n            if (Number.isFinite(width)) {\n              return layout.width * (width / 100);\n            }\n          }\n      }\n    }\n\n    if (props.scrollEnabled) {\n      return (layout.width / 5) * 2;\n    }\n\n    return layout.width / navigationState.routes.length;\n  };\n\n  _handleTabPress = ({ route }: Scene<*>) => {\n    this._pendingIndex = this.props.navigationState.routes.indexOf(route);\n\n    if (this.props.onTabPress) {\n      this.props.onTabPress({ route });\n    }\n\n    this.props.jumpTo(route.key);\n  };\n\n  _handleTabLongPress = ({ route }: Scene<*>) => {\n    if (this.props.onTabLongPress) {\n      this.props.onTabLongPress({ route });\n    }\n  };\n\n  _normalizeScrollValue = (props, value) => {\n    const { layout, navigationState } = props;\n    const tabWidth = this._getTabWidth(props);\n    const tabBarWidth = Math.max(\n      tabWidth * navigationState.routes.length,\n      layout.width\n    );\n    const maxDistance = tabBarWidth - layout.width;\n\n    return Math.max(Math.min(value, maxDistance), 0);\n  };\n\n  _getScrollAmount = (props, i) => {\n    const { layout } = props;\n    const tabWidth = this._getTabWidth(props);\n    const centerDistance = tabWidth * (i + 1 / 2);\n    const scrollAmount = centerDistance - layout.width / 2;\n\n    return this._normalizeScrollValue(props, scrollAmount);\n  };\n\n  _adjustScroll = (value: number) => {\n    if (this.props.scrollEnabled) {\n      global.cancelAnimationFrame(this._scrollResetCallback);\n      this._scrollView &&\n        this._scrollView.scrollTo({\n          x: this._normalizeScrollValue(\n            this.props,\n            this._getScrollAmount(this.props, value)\n          ),\n          animated: !this._isIntial, // Disable animation for the initial render\n        });\n\n      this._isIntial = false;\n    }\n  };\n\n  _resetScroll = (value: number, animated = true) => {\n    if (this.props.scrollEnabled) {\n      global.cancelAnimationFrame(this._scrollResetCallback);\n      this._scrollResetCallback = global.requestAnimationFrame(() => {\n        this._scrollView &&\n          this._scrollView.scrollTo({\n            x: this._getScrollAmount(this.props, value),\n            animated,\n          });\n      });\n    }\n  };\n\n  _handleBeginDrag = () => {\n    // onScrollBeginDrag fires when user touches the ScrollView\n    this._isManualScroll = true;\n    this._isMomentumScroll = false;\n  };\n\n  _handleEndDrag = () => {\n    // onScrollEndDrag fires when user lifts his finger\n    // onMomentumScrollBegin fires after touch end\n    // run the logic in next frame so we get onMomentumScrollBegin first\n    global.requestAnimationFrame(() => {\n      if (this._isMomentumScroll) {\n        return;\n      }\n      this._isManualScroll = false;\n    });\n  };\n\n  _handleMomentumScrollBegin = () => {\n    // onMomentumScrollBegin fires on flick, as well as programmatic scroll\n    this._isMomentumScroll = true;\n  };\n\n  _handleMomentumScrollEnd = () => {\n    // onMomentumScrollEnd fires when the scroll finishes\n    this._isMomentumScroll = false;\n    this._isManualScroll = false;\n  };\n\n  render() {\n    const { position, navigationState, scrollEnabled, bounces } = this.props;\n    const { routes } = navigationState;\n    const tabWidth = this._getTabWidth(this.props);\n    const tabBarWidth = tabWidth * routes.length;\n\n    // Prepend '-1', so there are always at least 2 items in inputRange\n    const inputRange = [-1, ...routes.map((x, i) => i)];\n    const translateX = Animated.multiply(this.state.scrollAmount, -1);\n\n    return (\n      <Animated.View style={[styles.tabBar, this.props.style]}>\n        <Animated.View\n          pointerEvents=\"none\"\n          style={[\n            styles.indicatorContainer,\n            scrollEnabled\n              ? { width: tabBarWidth, transform: [{ translateX }] }\n              : null,\n          ]}\n        >\n          {this._renderIndicator({\n            ...this.props,\n            width: tabWidth,\n          })}\n        </Animated.View>\n        <View style={styles.scroll}>\n          <Animated.ScrollView\n            horizontal\n            keyboardShouldPersistTaps=\"handled\"\n            scrollEnabled={scrollEnabled}\n            bounces={bounces}\n            alwaysBounceHorizontal={false}\n            scrollsToTop={false}\n            showsHorizontalScrollIndicator={false}\n            automaticallyAdjustContentInsets={false}\n            overScrollMode=\"never\"\n            contentContainerStyle={[\n              styles.tabContent,\n              scrollEnabled ? null : styles.container,\n            ]}\n            scrollEventThrottle={1}\n            onScroll={Animated.event(\n              [\n                {\n                  nativeEvent: {\n                    contentOffset: { x: this.state.scrollAmount },\n                  },\n                },\n              ],\n              { useNativeDriver }\n            )}\n            onScrollBeginDrag={this._handleBeginDrag}\n            onScrollEndDrag={this._handleEndDrag}\n            onMomentumScrollBegin={this._handleMomentumScrollBegin}\n            onMomentumScrollEnd={this._handleMomentumScrollEnd}\n            contentOffset={this.state.initialOffset}\n            ref={el => (this._scrollView = el && el.getNode())}\n          >\n            {routes.map((route, i) => {\n              const outputRange = inputRange.map(\n                inputIndex => (inputIndex === i ? 1 : 0.7)\n              );\n              const opacity = Animated.multiply(\n                this.state.visibility,\n                position.interpolate({\n                  inputRange,\n                  outputRange,\n                })\n              );\n              const label = this._renderLabel({ route });\n              const icon = this.props.renderIcon\n                ? this.props.renderIcon({ route })\n                : null;\n              const badge = this.props.renderBadge\n                ? this.props.renderBadge({ route })\n                : null;\n\n              const tabStyle = {};\n\n              tabStyle.opacity = opacity;\n\n              if (icon) {\n                if (label) {\n                  tabStyle.paddingTop = 8;\n                } else {\n                  tabStyle.padding = 12;\n                }\n              }\n\n              const passedTabStyle = StyleSheet.flatten(this.props.tabStyle);\n              const isWidthSet =\n                (passedTabStyle &&\n                  typeof passedTabStyle.width !== 'undefined') ||\n                scrollEnabled === true;\n              const tabContainerStyle = {};\n\n              if (isWidthSet) {\n                tabStyle.width = tabWidth;\n              }\n\n              if (passedTabStyle && typeof passedTabStyle.flex === 'number') {\n                tabContainerStyle.flex = passedTabStyle.flex;\n              } else if (!isWidthSet) {\n                tabContainerStyle.flex = 1;\n              }\n\n              let accessibilityLabel = this.props.getAccessibilityLabel({\n                route,\n              });\n\n              accessibilityLabel =\n                typeof accessibilityLabel !== 'undefined'\n                  ? accessibilityLabel\n                  : this.props.getLabelText({ route });\n\n              const isFocused = i === navigationState.index;\n\n              return (\n                <TouchableItem\n                  borderless\n                  key={route.key}\n                  testID={this.props.getTestID({ route })}\n                  accessible={this.props.getAccessible({ route })}\n                  accessibilityLabel={accessibilityLabel}\n                  accessibilityTraits={\n                    isFocused ? ['button', 'selected'] : 'button'\n                  }\n                  accessibilityComponentType=\"button\"\n                  accessibilityRole=\"button\"\n                  accessibilityStates={isFocused ? ['selected'] : []}\n                  pressColor={this.props.pressColor}\n                  pressOpacity={this.props.pressOpacity}\n                  delayPressIn={0}\n                  onPress={() => this._handleTabPress({ route })}\n                  onLongPress={() => this._handleTabLongPress({ route })}\n                  style={tabContainerStyle}\n                >\n                  <View pointerEvents=\"none\" style={styles.container}>\n                    <Animated.View\n                      style={[\n                        styles.tabItem,\n                        tabStyle,\n                        passedTabStyle,\n                        styles.container,\n                      ]}\n                    >\n                      {icon}\n                      {label}\n                    </Animated.View>\n                    {badge ? (\n                      <Animated.View\n                        style={[\n                          styles.badge,\n                          { opacity: this.state.visibility },\n                        ]}\n                      >\n                        {badge}\n                      </Animated.View>\n                    ) : null}\n                  </View>\n                </TouchableItem>\n              );\n            })}\n          </Animated.ScrollView>\n        </View>\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.OS === 'web' ? ('auto': any) : 'scroll',\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n    },\n    // We don't need zIndex on Android, disable it since it's buggy\n    zIndex: Platform.OS === 'android' ? 0 : 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  tabLabel: {\n    backgroundColor: 'transparent',\n    color: 'white',\n    margin: 8,\n  },\n  tabItem: {\n    flex: 1,\n    padding: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  badge: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2,\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}