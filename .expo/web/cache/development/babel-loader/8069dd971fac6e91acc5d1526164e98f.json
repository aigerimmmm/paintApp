{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport { AsyncStorage } from \"react-native-web/dist/index\";\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { polyfill } from 'react-lifecycles-compat';\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar urlToPathAndParams = pathUtils.urlToPathAndParams;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (isStateful(props)) {\n    return;\n  }\n\n  var navigation = props.navigation,\n      screenProps = props.screenProps,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  var NavigationContainer = function (_React$Component) {\n    _inherits(NavigationContainer, _React$Component);\n\n    var _super = _createSuper(NavigationContainer);\n\n    _createClass(NavigationContainer, null, [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        validateProps(nextProps);\n        return null;\n      }\n    }]);\n\n    function NavigationContainer(props) {\n      var _this;\n\n      _classCallCheck(this, NavigationContainer);\n\n      _this = _super.call(this, props);\n      _this.subs = null;\n      _this._actionEventSubscribers = new Set();\n\n      _this._handleOpenURL = function (_ref) {\n        var url = _ref.url;\n        var _this$props = _this.props,\n            enableURLHandling = _this$props.enableURLHandling,\n            uriPrefix = _this$props.uriPrefix;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var path = parsedUrl.path,\n              params = parsedUrl.params;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            _this.dispatch(action);\n          }\n        }\n      };\n\n      _this._persistNavigationState = function _callee(nav) {\n        var persistenceKey;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                persistenceKey = _this.props.persistenceKey;\n\n                if (persistenceKey) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return _regeneratorRuntime.awrap(AsyncStorage.setItem(persistenceKey, JSON.stringify(nav)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      };\n\n      _this.dispatch = function (action) {\n        if (_this.props.navigation) {\n          return _this.props.navigation.dispatch(action);\n        }\n\n        _this._navState = _this._navState || _this.state.nav;\n        var lastNavState = _this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = function dispatchActionEvents() {\n          _this._actionEventSubscribers.forEach(function (subscriber) {\n            return subscriber({\n              type: 'action',\n              action: action,\n              state: navState,\n              lastState: lastNavState\n            });\n          });\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          _this._navState = navState;\n\n          _this.setState({\n            nav: navState\n          }, function () {\n            _this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            _this._persistNavigationState(navState);\n          });\n\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      };\n\n      _this._getScreenProps = function () {\n        return _this.props.screenProps;\n      };\n\n      validateProps(props);\n      _this._initialAction = NavigationActions.init();\n\n      if (_this._isStateful()) {\n        _this.subs = BackHandler.addEventListener('hardwareBackPress', function () {\n          if (!_this._isMounted) {\n            _this.subs && _this.subs.remove();\n          } else {\n            return _this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      _this.state = {\n        nav: _this._isStateful() && !props.persistenceKey ? Component.router.getStateForAction(_this._initialAction) : null\n      };\n      return _this;\n    }\n\n    _createClass(NavigationContainer, [{\n      key: \"_renderLoading\",\n      value: function _renderLoading() {\n        return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n      }\n    }, {\n      key: \"_isStateful\",\n      value: function _isStateful() {\n        return isStateful(this.props);\n      }\n    }, {\n      key: \"_validateProps\",\n      value: function _validateProps(props) {\n        if (this._isStateful()) {\n          return;\n        }\n\n        var navigation = props.navigation,\n            screenProps = props.screenProps,\n            containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n        var keys = Object.keys(containerProps);\n\n        if (keys.length !== 0) {\n          throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n        }\n      }\n    }, {\n      key: \"_onNavigationStateChange\",\n      value: function _onNavigationStateChange(prevNav, nav, action) {\n        if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n          if (console.group) {\n            console.group('Navigation Dispatch: ');\n            console.log('Action: ', action);\n            console.log('New State: ', nav);\n            console.log('Last State: ', prevNav);\n            console.groupEnd();\n          } else {\n            console.log('Navigation Dispatch: ', {\n              action: action,\n              newState: nav,\n              lastState: prevNav\n            });\n          }\n\n          return;\n        }\n\n        if (typeof this.props.onNavigationStateChange === 'function') {\n          this.props.onNavigationStateChange(prevNav, nav, action);\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this._navState === this.state.nav) {\n          this._navState = null;\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        var _this$props2, persistenceKey, uriPrefix, enableURLHandling, parsedUrl, startupStateJSON, url, action, startupState, _parsedUrl, path, params, urlAction, dispatchActions;\n\n        return _regeneratorRuntime.async(function componentDidMount$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._isMounted = true;\n\n                if (this._isStateful()) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                if (__DEV__ && !this.props.detached) {\n                  if (_statefulContainerCount > 0) {\n                    if (Platform.OS === 'ios') {\n                      console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \" + docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator'));\n                    }\n                  }\n                }\n\n                _statefulContainerCount++;\n                Linking.addEventListener('url', this._handleOpenURL);\n                _this$props2 = this.props, persistenceKey = _this$props2.persistenceKey, uriPrefix = _this$props2.uriPrefix, enableURLHandling = _this$props2.enableURLHandling;\n                parsedUrl = null;\n                startupStateJSON = null;\n\n                if (!(enableURLHandling !== false)) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                _context2.t0 = persistenceKey;\n\n                if (!_context2.t0) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.next = 14;\n                return _regeneratorRuntime.awrap(AsyncStorage.getItem(persistenceKey));\n\n              case 14:\n                _context2.t0 = _context2.sent;\n\n              case 15:\n                startupStateJSON = _context2.t0;\n                _context2.next = 18;\n                return _regeneratorRuntime.awrap(Linking.getInitialURL());\n\n              case 18:\n                url = _context2.sent;\n                parsedUrl = url && urlToPathAndParams(url, uriPrefix);\n\n              case 20:\n                action = this._initialAction;\n                startupState = this.state.nav;\n\n                if (!startupState) {\n                  !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n                  startupState = Component.router.getStateForAction(action);\n                }\n\n                if (startupStateJSON) {\n                  try {\n                    startupState = JSON.parse(startupStateJSON);\n                    _reactNavigationIsHydratingState = true;\n                  } catch (e) {}\n                }\n\n                if (parsedUrl) {\n                  _parsedUrl = parsedUrl, path = _parsedUrl.path, params = _parsedUrl.params;\n                  urlAction = Component.router.getActionForPathAndParams(path, params);\n\n                  if (urlAction) {\n                    !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n                    action = urlAction;\n                    startupState = Component.router.getStateForAction(urlAction, startupState);\n                  }\n                }\n\n                dispatchActions = function dispatchActions() {\n                  return _this2._actionEventSubscribers.forEach(function (subscriber) {\n                    return subscriber({\n                      type: 'action',\n                      action: action,\n                      state: _this2.state.nav,\n                      lastState: null\n                    });\n                  });\n                };\n\n                if (!(startupState === this.state.nav)) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                dispatchActions();\n                return _context2.abrupt(\"return\");\n\n              case 29:\n                this.setState({\n                  nav: startupState\n                }, function () {\n                  _reactNavigationIsHydratingState = false;\n                  dispatchActions();\n                });\n\n              case 30:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, this, null, Promise);\n      }\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(e) {\n        if (_reactNavigationIsHydratingState) {\n          _reactNavigationIsHydratingState = false;\n          console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state..');\n          this.dispatch(NavigationActions.init());\n        } else {\n          throw e;\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._isMounted = false;\n        Linking.removeEventListener('url', this._handleOpenURL);\n        this.subs && this.subs.remove();\n\n        if (this._isStateful()) {\n          _statefulContainerCount--;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var navigation = this.props.navigation;\n\n        if (this._isStateful()) {\n          var navState = this.state.nav;\n\n          if (!navState) {\n            return this._renderLoading();\n          }\n\n          if (!this._navigation || this._navigation.state !== navState) {\n            this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, function () {\n              return _this3._navigation;\n            });\n          }\n\n          navigation = this._navigation;\n        }\n\n        invariant(navigation, 'failed to get navigation');\n        return React.createElement(NavigationProvider, {\n          value: navigation\n        }, React.createElement(Component, _extends({}, this.props, {\n          navigation: navigation\n        })));\n      }\n    }]);\n\n    return NavigationContainer;\n  }(React.Component);\n\n  NavigationContainer.router = Component.router;\n  NavigationContainer.navigationOptions = null;\n  return polyfill(NavigationContainer);\n}","map":{"version":3,"names":["React","AsyncStorage","polyfill","NavigationActions","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","screenProps","containerProps","keys","Object","length","Error","join","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","nextProps","subs","_actionEventSubscribers","Set","_handleOpenURL","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","nav","persistenceKey","setItem","JSON","stringify","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_getScreenProps","_initialAction","init","_isStateful","BackHandler","addEventListener","_isMounted","remove","back","renderLoadingExperimental","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","console","group","log","groupEnd","newState","__DEV__","detached","Platform","OS","warn","Linking","startupStateJSON","getItem","getInitialURL","startupState","parse","e","urlAction","dispatchActions","removeEventListener","_renderLoading","_navigation","navigationOptions"],"sources":["C:/Users/mike/Desktop/ha/DrawingKid_Expo_20210705/node_modules/@react-navigation/native/dist/createAppContainer.js"],"sourcesContent":["import React from 'react';\nimport { AsyncStorage, Linking, Platform, BackHandler } from 'react-native';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (isStateful(props)) {\n    return;\n  }\n  // eslint-disable-next-line no-unused-vars\n  const { navigation, screenProps, ...containerProps } = props;\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful()) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.persistenceKey ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (__DEV__ && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(`You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')}`);\n          }\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      const { persistenceKey, uriPrefix, enableURLHandling } = this.props;\n      let parsedUrl = null;\n      let startupStateJSON = null;\n      if (enableURLHandling !== false) {\n        startupStateJSON = persistenceKey && (await AsyncStorage.getItem(persistenceKey));\n        const url = await Linking.getInitialURL();\n        parsedUrl = url && urlToPathAndParams(url, uriPrefix);\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      let startupState = this.state.nav;\n      if (!startupState) {\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull persisted state from AsyncStorage\n      if (startupStateJSON) {\n        try {\n          startupState = JSON.parse(startupStateJSON);\n          _reactNavigationIsHydratingState = true;\n        } catch (e) {\n          /* do nothing */\n        }\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(urlAction, startupState);\n        }\n      }\n\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\n        type: 'action',\n        action,\n        state: this.state.nav,\n        lastState: null\n      }));\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state..');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistenceKey } = this.props;\n      if (!persistenceKey) {\n        return;\n      }\n      await AsyncStorage.setItem(persistenceKey, JSON.stringify(nav));\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(action, lastNavState);\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: navState,\n          lastState: lastNavState\n        }));\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <NavigationProvider value={navigation}>\n          <Component {...this.props} navigation={navigation} />\n        </NavigationProvider>;\n    }\n  }\n\n  return polyfill(NavigationContainer);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}