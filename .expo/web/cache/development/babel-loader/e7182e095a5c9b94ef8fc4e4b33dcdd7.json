{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport NavigationActions from \"../NavigationActions\";\nimport StackActions from \"./StackActions\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport StateUtils from \"../StateUtils\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport invariant from \"../utils/invariant\";\nimport { generateKey } from \"./KeyGenerator\";\nimport { createPathParser } from \"./pathUtils\";\n\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\n\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (function (routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n\n      if (childRouter !== null) {\n        var childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread({\n          params: action.params\n        }, childState, {\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        })]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    var params = (routeConfigs[initialRouteName].params || route.params || action.params || initialRouteParams) && _objectSpread({}, routeConfigs[initialRouteName].params || {}, route.params || {}, action.params || {}, initialRouteParams || {});\n\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread({}, route, params ? {\n      params: params\n    } : {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    var routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, action.params);\n    } else {\n      return action.params;\n    }\n  }\n\n  var _createPathParser = createPathParser(childRouters, routeConfigs, stackConfig),\n      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  return {\n    childRouters: childRouters,\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return _objectSpread({}, getCustomActionCreators(route, navStateKey), {\n        pop: function pop(n, params) {\n          return StackActions.pop(_objectSpread({\n            n: n\n          }, params));\n        },\n        popToTop: function popToTop(params) {\n          return StackActions.popToTop(params);\n        },\n        push: function push(routeName, params, action) {\n          return StackActions.push({\n            routeName: routeName,\n            params: params,\n            action: action\n          });\n        },\n        replace: function replace(replaceWith, params, action, newKey) {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params: params,\n              action: action,\n              key: route.key,\n              newKey: newKey\n            });\n          }\n\n          invariant(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          invariant(params == null, 'Params must not be provided to .replace() when specifying an object');\n          invariant(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          invariant(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: function reset(actions, index) {\n          return StackActions.reset({\n            actions: actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey\n          });\n        },\n        dismiss: function dismiss() {\n          return NavigationActions.back({\n            key: navStateKey\n          });\n        }\n      });\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      var activeChildRoute = state.routes[state.index];\n\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        var activeChildRouter = childRouters[activeChildRoute.routeName];\n\n        if (activeChildRouter) {\n          var route = activeChildRouter.getStateForAction(action, activeChildRoute);\n\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(state, activeChildRoute.key, route, action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        for (var _iterator = _createForOfIteratorHelperLoose(state.routes.slice().reverse()), _step; !(_step = _iterator()).done;) {\n          var childRoute = _step.value;\n          var childRouter = childRouters[childRoute.routeName];\n          var childAction = action.routeName === childRoute.routeName && action.action ? action.action : action;\n\n          if (childRouter) {\n            var nextRouteState = childRouter.getStateForAction(childAction, childRoute);\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              var newState = StateUtils.replaceAndPrune(state, nextRouteState ? nextRouteState.key : childRoute.key, nextRouteState ? nextRouteState : childRoute);\n              return _objectSpread({}, newState, {\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              });\n            }\n          }\n        }\n      }\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter = childRouters[action.routeName];\n\n        var _route;\n\n        invariant(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n        var lastRouteIndex = state.routes.findIndex(function (r) {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          var routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          if (action.params) {\n            var _route2 = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = _objectSpread({}, _route2, {\n              params: _objectSpread({}, _route2.params, action.params)\n            });\n          }\n\n          return _objectSpread({}, state, {\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes: routes\n          });\n        }\n\n        if (_childRouter) {\n          var _childAction = action.action || NavigationActions.init({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          });\n\n          _route = _objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, _childRouter.getStateForAction(_childAction), {\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          });\n        } else {\n          _route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n\n        return _objectSpread({}, StateUtils.push(state, _route), {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        return state;\n      }\n\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter2 = childRouters[childRouterName];\n\n          if (_childRouter2) {\n            var initChildRoute = _childRouter2.getStateForAction(NavigationActions.init());\n\n            var navigatedChildRoute = _childRouter2.getStateForAction(action, initChildRoute);\n\n            var routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              var _route3 = _objectSpread({}, routeToPush, {\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              });\n\n              return _objectSpread({}, StateUtils.push(state, _route3), {\n                isTransitioning: action.immediate !== true\n              });\n            }\n          }\n        }\n      }\n\n      if (action.type === StackActions.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        if (state.index > 0) {\n          return _objectSpread({}, state, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n\n        return state;\n      }\n\n      if (action.type === StackActions.REPLACE) {\n        var routeIndex;\n\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(function (r) {\n            return r.key === action.key;\n          });\n        }\n\n        if (routeIndex !== -1) {\n          var _childRouter3 = childRouters[action.routeName];\n          var childState = {};\n\n          if (_childRouter3) {\n            var _childAction2 = action.action || NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action)\n            });\n\n            childState = _childRouter3.getStateForAction(_childAction2);\n          }\n\n          var _routes = _toConsumableArray(state.routes);\n\n          _routes[routeIndex] = _objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, childState, {\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          });\n          return _objectSpread({}, state, {\n            routes: _routes\n          });\n        }\n      }\n\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && action.toChildKey === state.routes[state.index].key && state.isTransitioning) {\n        return _objectSpread({}, state, {\n          isTransitioning: false\n        });\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var params = _objectSpread({}, lastRoute.params, action.params);\n\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: params\n          });\n          return _objectSpread({}, state, {\n            routes: _routes2\n          });\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        if (action.key != null && action.key != state.key) {\n          return state;\n        }\n\n        var newStackActions = action.actions;\n        return _objectSpread({}, state, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n\n            if (router) {\n              var _childAction3 = newStackAction.action || NavigationActions.init({\n                params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n              });\n\n              childState = router.getStateForAction(_childAction3);\n            }\n\n            return _objectSpread({\n              params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n            }, childState, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            });\n          }),\n          index: action.index\n        });\n      }\n\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        var _key = action.key,\n            n = action.n,\n            immediate = action.immediate;\n        var backRouteIndex = state.index;\n\n        if (action.type === StackActions.POP && n != null) {\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (_key) {\n          var backRoute = state.routes.find(function (route) {\n            return route.key === _key;\n          });\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return _objectSpread({}, state, {\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          });\n        }\n      }\n\n      var keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(state.routes.slice().reverse()), _step2; !(_step2 = _iterator2()).done;) {\n        var _childRoute = _step2.value;\n\n        if (_childRoute.key === activeChildRoute.key) {\n          continue;\n        }\n\n        if (keyIndex >= 0 && _childRoute.key !== action.key) {\n          continue;\n        }\n\n        var _childRouter4 = childRouters[_childRoute.routeName];\n\n        if (_childRouter4) {\n          var _route4 = _childRouter4.getStateForAction(action, _childRoute);\n\n          if (_route4 === null) {\n            return state;\n          } else if (_route4 && _route4 !== _childRoute) {\n            return StateUtils.replaceAt(state, _childRoute.key, _route4, action.type === NavigationActions.SET_PARAMS || action.type === StackActions.COMPLETE_TRANSITION || action.type.includes('DRAWER'));\n          }\n        }\n      }\n\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["../../src/routers/StackRouter.js"],"names":["action","NavigationActions","StackActions","defaultActionCreators","stackConfig","validateRouteConfigMap","childRouters","routeNames","Object","routeName","screen","getScreenForRouteName","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","route","childRouter","behavesLikePushAction","childState","childAction","params","key","isTransitioning","index","routes","generateKey","routeConfigs","initialRouteKey","routeConfig","getActionForPathAndParams","createPathParser","getComponentForState","activeChildRoute","state","getComponentForRouteName","getActionCreators","pop","n","popToTop","push","replace","newKey","invariant","reset","actions","navStateKey","dismiss","getStateForAction","getInitialState","isResetToRootStack","activeChildRouter","StateUtils","childRoute","nextRouteState","newState","lastRouteIndex","r","getParamsForRouteAndAction","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","routeIndex","lastRoute","newStackActions","newStackAction","router","immediate","backRouteIndex","Math","backRoute","keyIndex","getPathAndParamsForState","getPathAndParamsForRoute","getScreenOptions","createConfigGetter"],"mappings":"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","sourcesContent":["import NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action or complete transition action,\n              // because people don't expect these actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS ||\n                action.type === StackActions.COMPLETE_TRANSITION ||\n                action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}