{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { SceneView, StackActions, NavigationActions, NavigationProvider } from '@react-navigation/core';\nimport { withOrientation } from '@react-navigation/native';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Card from \"./StackViewCard\";\nimport Header from \"../Header/Header\";\nimport TransitionConfigs from \"./StackViewTransitionConfigs\";\nimport HeaderStyleInterpolator from \"../Header/HeaderStyleInterpolator\";\nimport StackGestureContext from \"../../utils/StackGestureContext\";\nimport clamp from \"../../utils/clamp\";\nimport { supportsImprovedSpringAnimation } from \"../../utils/ReactNativeFeatures\";\nvar IPHONE_XS_HEIGHT = 812;\nvar IPHONE_XR_HEIGHT = 896;\n\nvar _Dimensions$get = Dimensions.get('window'),\n    WINDOW_WIDTH = _Dimensions$get.width,\n    WINDOW_HEIGHT = _Dimensions$get.height;\n\nvar IS_IPHONE_X = Platform.OS === 'ios' && !Platform.isPad && !Platform.isTVOS && (WINDOW_HEIGHT === IPHONE_XS_HEIGHT || WINDOW_WIDTH === IPHONE_XS_HEIGHT || WINDOW_HEIGHT === IPHONE_XR_HEIGHT || WINDOW_WIDTH === IPHONE_XR_HEIGHT);\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar HEADER_LAYOUT_PRESET = ['center', 'left'];\nvar HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nvar HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nvar USE_NATIVE_DRIVER = true;\n\nvar getDefaultHeaderHeight = function getDefaultHeaderHeight(isLandscape) {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else {\n    return 56;\n  }\n};\n\nvar StackViewLayout = function (_React$Component) {\n  _inherits(StackViewLayout, _React$Component);\n\n  var _super = _createSuper(StackViewLayout);\n\n  function StackViewLayout(props) {\n    var _this;\n\n    _classCallCheck(this, StackViewLayout);\n\n    _this = _super.call(this, props);\n    _this._immediateIndex = null;\n\n    _this._onFloatingHeaderLayout = function (e) {\n      var height = e.nativeEvent.layout.height;\n\n      if (height !== _this.state.floatingHeaderHeight) {\n        _this.setState({\n          floatingHeaderHeight: height\n        });\n      }\n    };\n\n    _this._handlePanGestureStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n\n      if (nativeEvent.oldState === State.ACTIVE) {\n        if (_this.positionSwitch.__getValue() === 1) {\n          return;\n        }\n\n        if (_this._isMotionVertical()) {\n          _this._handleReleaseVertical(nativeEvent);\n        } else {\n          _this._handleReleaseHorizontal(nativeEvent);\n        }\n      } else if (nativeEvent.state === State.ACTIVE) {\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n\n        _this.positionSwitch.setValue(0);\n      }\n    };\n\n    _this._renderCard = function (scene) {\n      var _this$props = _this.props,\n          transitionProps = _this$props.transitionProps,\n          shadowEnabled = _this$props.shadowEnabled,\n          cardOverlayEnabled = _this$props.cardOverlayEnabled,\n          transparentCard = _this$props.transparentCard,\n          cardStyle = _this$props.cardStyle;\n      var screenInterpolator = _this._transitionConfig.screenInterpolator;\n      var style = screenInterpolator && screenInterpolator(_objectSpread(_objectSpread({}, transitionProps), {}, {\n        shadowEnabled: shadowEnabled,\n        cardOverlayEnabled: cardOverlayEnabled,\n        position: _this.position,\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null;\n\n      var headerMode = _this._getHeaderMode();\n\n      var paddingTopStyle;\n\n      if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n        paddingTopStyle = {\n          paddingTop: _this.state.floatingHeaderHeight\n        };\n      }\n\n      return React.createElement(Card, _extends({}, transitionProps, {\n        key: \"card_\" + scene.key,\n        position: _this.position,\n        realPosition: transitionProps.position,\n        animatedStyle: style,\n        transparent: transparentCard,\n        style: [paddingTopStyle, cardStyle],\n        scene: scene\n      }), _this._renderInnerScene(scene));\n    };\n\n    _this.panGestureRef = React.createRef();\n    _this.gestureX = new Animated.Value(0);\n    _this.gestureY = new Animated.Value(0);\n    _this.positionSwitch = new Animated.Value(1);\n\n    if (Animated.subtract) {\n      _this.gestureSwitch = Animated.subtract(1, _this.positionSwitch);\n    } else {\n      _this.gestureSwitch = Animated.add(1, Animated.multiply(-1, _this.positionSwitch));\n    }\n\n    _this.gestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: _this.gestureX,\n        translationY: _this.gestureY\n      }\n    }], {\n      useNativeDriver: USE_NATIVE_DRIVER\n    });\n    _this.state = {\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape)\n    };\n    return _this;\n  }\n\n  _createClass(StackViewLayout, [{\n    key: \"_renderHeader\",\n    value: function _renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header;\n\n      if (__DEV__ && typeof header === 'string') {\n        throw new Error(\"Invalid header value: \\\"\" + header + \"\\\". The header option must be a valid React component or null, not a string.\");\n      }\n\n      if (header === null && headerMode === 'screen') {\n        return null;\n      }\n\n      if (React.isValidElement(header)) {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, props);\n      };\n\n      var _this$_transitionConf = this._transitionConfig,\n          headerLeftInterpolator = _this$_transitionConf.headerLeftInterpolator,\n          headerTitleInterpolator = _this$_transitionConf.headerTitleInterpolator,\n          headerRightInterpolator = _this$_transitionConf.headerRightInterpolator,\n          headerBackgroundInterpolator = _this$_transitionConf.headerBackgroundInterpolator;\n\n      var backgroundTransitionPresetInterpolator = this._getHeaderBackgroundTransitionPreset();\n\n      if (backgroundTransitionPresetInterpolator) {\n        headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n      }\n\n      var _this$props2 = this.props,\n          transitionProps = _this$props2.transitionProps,\n          passProps = _objectWithoutProperties(_this$props2, [\"transitionProps\"]);\n\n      return React.createElement(NavigationProvider, {\n        value: scene.descriptor.navigation\n      }, renderHeader(_objectSpread(_objectSpread(_objectSpread({}, passProps), transitionProps), {}, {\n        position: this.position,\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this._getHeaderTransitionPreset(),\n        layoutPreset: this._getHeaderLayoutPreset(),\n        backTitleVisible: this._getHeaderBackTitleVisible(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator,\n        backgroundInterpolator: headerBackgroundInterpolator\n      })));\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 6000,\n          damping: 100,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      }\n    }\n  }, {\n    key: \"_goBack\",\n    value: function _goBack(backFromIndex, duration) {\n      var _this2 = this;\n\n      var _this$props$transitio = this.props.transitionProps,\n          navigation = _this$props$transitio.navigation,\n          position = _this$props$transitio.position,\n          scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this._immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2._immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(StackActions.completeTransition());\n        }\n      };\n\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 7000,\n          damping: 300,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"_prepareAnimated\",\n    value: function _prepareAnimated() {\n      if (this.props === this._prevProps) {\n        return;\n      }\n\n      this._prevProps = this.props;\n\n      this._prepareGesture();\n\n      this._preparePosition();\n\n      this._prepareTransitionConfig();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this._prepareAnimated();\n\n      var transitionProps = this.props.transitionProps;\n      var index = transitionProps.navigation.state.index,\n          scenes = transitionProps.scenes;\n\n      var headerMode = this._getHeaderMode();\n\n      var floatingHeader = null;\n\n      if (headerMode === 'float') {\n        var scene = transitionProps.scene;\n        floatingHeader = React.createElement(View, {\n          style: styles.floatingHeader,\n          pointerEvents: \"box-none\",\n          onLayout: this._onFloatingHeaderLayout\n        }, this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(PanGestureHandler, _extends({}, this._gestureActivationCriteria(), {\n        ref: this.panGestureRef,\n        onGestureEvent: this.gestureEvent,\n        onHandlerStateChange: this._handlePanGestureStateChange,\n        enabled: index > 0 && this._isGestureEnabled()\n      }), React.createElement(Animated.View, {\n        style: [styles.container, this._transitionConfig.containerStyle]\n      }, React.createElement(StackGestureContext.Provider, {\n        value: this.panGestureRef\n      }, React.createElement(ScreenContainer, {\n        style: styles.scenes\n      }, scenes.map(this._renderCard)), floatingHeader)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevState = prevProps.transitionProps.navigation.state;\n      var state = this.props.transitionProps.navigation.state;\n\n      if (prevState.index !== state.index) {\n        this._maybeCancelGesture();\n      }\n    }\n  }, {\n    key: \"_getGestureResponseDistance\",\n    value: function _getGestureResponseDistance() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var _options$gestureRespo = options.gestureResponseDistance,\n          userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n      return this._isModal() ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n    }\n  }, {\n    key: \"_gestureActivationCriteria\",\n    value: function _gestureActivationCriteria() {\n      var layout = this.props.transitionProps.layout;\n\n      var gestureResponseDistance = this._getGestureResponseDistance();\n\n      var isMotionInverted = this._isMotionInverted();\n\n      if (this._isMotionVertical()) {\n        var height = layout.height.__getValue();\n\n        return {\n          maxDeltaX: 15,\n          minOffsetY: isMotionInverted ? -5 : 5,\n          hitSlop: isMotionInverted ? {\n            top: -height + gestureResponseDistance\n          } : {\n            bottom: -height + gestureResponseDistance\n          }\n        };\n      } else {\n        var width = layout.width.__getValue();\n\n        var hitSlop = -width + gestureResponseDistance;\n        return {\n          minOffsetX: isMotionInverted ? -5 : 5,\n          maxDeltaY: 20,\n          hitSlop: isMotionInverted ? {\n            left: hitSlop\n          } : {\n            right: hitSlop\n          }\n        };\n      }\n    }\n  }, {\n    key: \"_isGestureEnabled\",\n    value: function _isGestureEnabled() {\n      var gesturesEnabled = this.props.transitionProps.scene.descriptor.options.gesturesEnabled;\n      return typeof gesturesEnabled === 'boolean' ? gesturesEnabled : Platform.OS === 'ios';\n    }\n  }, {\n    key: \"_isMotionVertical\",\n    value: function _isMotionVertical() {\n      return this._isModal();\n    }\n  }, {\n    key: \"_isModal\",\n    value: function _isModal() {\n      return this.props.mode === 'modal';\n    }\n  }, {\n    key: \"_isMotionInverted\",\n    value: function _isMotionInverted() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n\n      if (this._isModal()) {\n        return gestureDirection === 'inverted';\n      } else {\n        return typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n      }\n    }\n  }, {\n    key: \"_computeHorizontalGestureValue\",\n    value: function _computeHorizontalGestureValue(_ref2) {\n      var translationX = _ref2.translationX;\n      var _this$props$transitio2 = this.props.transitionProps,\n          navigation = _this$props$transitio2.navigation,\n          layout = _this$props$transitio2.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.width.__getValue();\n\n      var x = this._isMotionInverted() ? -1 * translationX : translationX;\n      var value = index - x / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"_computeVerticalGestureValue\",\n    value: function _computeVerticalGestureValue(_ref3) {\n      var translationY = _ref3.translationY;\n      var _this$props$transitio3 = this.props.transitionProps,\n          navigation = _this$props$transitio3.navigation,\n          layout = _this$props$transitio3.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.height.__getValue();\n\n      var y = this._isMotionInverted() ? -1 * translationY : translationY;\n      var value = index - y / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"_maybeCancelGesture\",\n    value: function _maybeCancelGesture() {\n      this.positionSwitch.setValue(1);\n    }\n  }, {\n    key: \"_prepareGesture\",\n    value: function _prepareGesture() {\n      if (!this._isGestureEnabled()) {\n        if (this.positionSwitch.__getValue() !== 1) {\n          this.positionSwitch.setValue(1);\n        }\n\n        this.gesturePosition = undefined;\n        return;\n      }\n\n      if (this.props.transitionProps.layout.width.__getValue() === 0 || this.props.transitionProps.layout.height.__getValue() === 0) {\n        return;\n      }\n\n      if (this._isMotionVertical()) {\n        this._prepareGestureVertical();\n      } else {\n        this._prepareGestureHorizontal();\n      }\n    }\n  }, {\n    key: \"_prepareGestureHorizontal\",\n    value: function _prepareGestureHorizontal() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this._isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureX, this.props.transitionProps.layout.width)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureX, this.props.transitionProps.layout.width))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"_prepareGestureVertical\",\n    value: function _prepareGestureVertical() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this._isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureY, this.props.transitionProps.layout.height)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureY, this.props.transitionProps.layout.height))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"_handleReleaseHorizontal\",\n    value: function _handleReleaseHorizontal(nativeEvent) {\n      var _this$props$transitio4 = this.props.transitionProps,\n          navigation = _this$props$transitio4.navigation,\n          position = _this$props$transitio4.position,\n          layout = _this$props$transitio4.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n\n      var distance = layout.width.__getValue();\n\n      var movementDirection = this._isMotionInverted() ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationX;\n      var gestureVelocity = movementDirection * nativeEvent.velocityX;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = this._isMotionInverted() ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = this._isMotionInverted() ? movedDistance / velocity : (distance - movedDistance) / velocity;\n\n      var value = this._computeHorizontalGestureValue(nativeEvent);\n\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"_handleReleaseVertical\",\n    value: function _handleReleaseVertical(nativeEvent) {\n      var _this$props$transitio5 = this.props.transitionProps,\n          navigation = _this$props$transitio5.navigation,\n          position = _this$props$transitio5.position,\n          layout = _this$props$transitio5.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this._immediateIndex == null ? index : this._immediateIndex;\n\n      var distance = layout.height.__getValue();\n\n      var isMotionInverted = this._isMotionInverted();\n\n      var movementDirection = isMotionInverted ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationY;\n      var gestureVelocity = movementDirection * nativeEvent.velocityY;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = isMotionInverted ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = isMotionInverted ? movedDistance / velocity : (distance - movedDistance) / velocity;\n\n      var value = this._computeVerticalGestureValue(nativeEvent);\n\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n\n        this._goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n\n        this._reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"_getHeaderMode\",\n    value: function _getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (Platform.OS !== 'ios' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"_getHeaderBackgroundTransitionPreset\",\n    value: function _getHeaderBackgroundTransitionPreset() {\n      var headerBackgroundTransitionPreset = this.props.headerBackgroundTransitionPreset;\n\n      if (headerBackgroundTransitionPreset) {\n        if (HEADER_BACKGROUND_TRANSITION_PRESET.includes(headerBackgroundTransitionPreset)) {\n          if (headerBackgroundTransitionPreset === 'fade') {\n            return HeaderStyleInterpolator.forBackgroundWithFade;\n          } else if (headerBackgroundTransitionPreset === 'translate') {\n            return HeaderStyleInterpolator.forBackgroundWithTranslation;\n          } else if (headerBackgroundTransitionPreset === 'toggle') {\n            return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n          }\n        } else if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerBackgroundTransitionPreset - expected one of \" + HEADER_BACKGROUND_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerBackgroundTransitionPreset));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getHeaderLayoutPreset\",\n    value: function _getHeaderLayoutPreset() {\n      var headerLayoutPreset = this.props.headerLayoutPreset;\n\n      if (headerLayoutPreset) {\n        if (__DEV__) {\n          if (this._getHeaderTransitionPreset() === 'uikit' && headerLayoutPreset === 'left' && Platform.OS === 'ios') {\n            console.warn(\"headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'\");\n          }\n        }\n\n        if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n          return headerLayoutPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerLayoutPreset - expected one of \" + HEADER_LAYOUT_PRESET.join(', ') + \" but received \" + JSON.stringify(headerLayoutPreset));\n        }\n      }\n\n      if (Platform.OS !== 'ios') {\n        return 'left';\n      } else {\n        return 'center';\n      }\n    }\n  }, {\n    key: \"_getHeaderTransitionPreset\",\n    value: function _getHeaderTransitionPreset() {\n      if (Platform.OS !== 'ios' || this._getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      var headerTransitionPreset = this.props.headerTransitionPreset;\n\n      if (headerTransitionPreset) {\n        if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n          return headerTransitionPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerTransitionPreset - expected one of \" + HEADER_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerTransitionPreset));\n        }\n      }\n\n      return 'fade-in-place';\n    }\n  }, {\n    key: \"_getHeaderBackTitleVisible\",\n    value: function _getHeaderBackTitleVisible() {\n      var headerBackTitleVisible = this.props.headerBackTitleVisible;\n\n      var layoutPreset = this._getHeaderLayoutPreset();\n\n      var enabledByDefault = !(layoutPreset === 'left' || Platform.OS !== 'ios');\n      return typeof headerBackTitleVisible === 'boolean' ? headerBackTitleVisible : enabledByDefault;\n    }\n  }, {\n    key: \"_renderInnerScene\",\n    value: function _renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n          navigation = _scene$descriptor.navigation,\n          getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n\n      var headerMode = this._getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container\n        }, React.createElement(View, {\n          style: styles.scenes\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent\n        })), this._renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent\n      });\n    }\n  }, {\n    key: \"_prepareTransitionConfig\",\n    value: function _prepareTransitionConfig() {\n      this._transitionConfig = TransitionConfigs.getTransitionConfig(this.props.transitionConfig, _objectSpread(_objectSpread({}, this.props.transitionProps), {}, {\n        position: this.position\n      }), this.props.lastTransitionProps, this._isModal());\n    }\n  }, {\n    key: \"_preparePosition\",\n    value: function _preparePosition() {\n      if (this.gesturePosition) {\n        this.position = Animated.add(Animated.multiply(this.props.transitionProps.position, this.positionSwitch), Animated.multiply(this.gesturePosition, this.gestureSwitch));\n      } else {\n        this.position = this.props.transitionProps.position;\n      }\n    }\n  }]);\n\n  return StackViewLayout;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n    overflow: 'hidden'\n  },\n  scenes: {\n    flex: 1\n  },\n  floatingHeader: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0\n  }\n});\nexport default withOrientation(StackViewLayout);","map":{"version":3,"names":["React","SceneView","StackActions","NavigationActions","NavigationProvider","withOrientation","ScreenContainer","PanGestureHandler","State","Card","Header","TransitionConfigs","HeaderStyleInterpolator","StackGestureContext","clamp","supportsImprovedSpringAnimation","IPHONE_XS_HEIGHT","IPHONE_XR_HEIGHT","Dimensions","get","WINDOW_WIDTH","width","WINDOW_HEIGHT","height","IS_IPHONE_X","Platform","OS","isPad","isTVOS","EaseInOut","Easing","inOut","ease","HEADER_LAYOUT_PRESET","HEADER_TRANSITION_PRESET","HEADER_BACKGROUND_TRANSITION_PRESET","ANIMATION_DURATION","POSITION_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","USE_NATIVE_DRIVER","getDefaultHeaderHeight","isLandscape","StackViewLayout","props","_immediateIndex","_onFloatingHeaderLayout","e","nativeEvent","layout","state","floatingHeaderHeight","setState","_handlePanGestureStateChange","oldState","ACTIVE","positionSwitch","__getValue","_isMotionVertical","_handleReleaseVertical","_handleReleaseHorizontal","onGestureBegin","setValue","_renderCard","scene","transitionProps","shadowEnabled","cardOverlayEnabled","transparentCard","cardStyle","screenInterpolator","_transitionConfig","style","position","options","descriptor","hasHeader","header","headerMode","_getHeaderMode","paddingTopStyle","headerTransparent","paddingTop","key","_renderInnerScene","panGestureRef","createRef","gestureX","Animated","Value","gestureY","subtract","gestureSwitch","add","multiply","gestureEvent","event","translationX","translationY","useNativeDriver","__DEV__","Error","isValidElement","renderHeader","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","headerBackgroundInterpolator","backgroundTransitionPresetInterpolator","_getHeaderBackgroundTransitionPreset","passProps","navigation","mode","transitionPreset","_getHeaderTransitionPreset","layoutPreset","_getHeaderLayoutPreset","backTitleVisible","_getHeaderBackTitleVisible","leftInterpolator","titleInterpolator","rightInterpolator","backgroundInterpolator","resetToIndex","duration","spring","toValue","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","start","timing","easing","backFromIndex","scenes","Math","max","onCompleteAnimation","backFromScene","find","s","index","dispatch","back","route","immediate","completeTransition","_prevProps","_prepareGesture","_preparePosition","_prepareTransitionConfig","_prepareAnimated","floatingHeader","styles","_renderHeader","_gestureActivationCriteria","_isGestureEnabled","container","containerStyle","map","prevProps","prevState","_maybeCancelGesture","gestureResponseDistance","userGestureResponseDistance","_isModal","vertical","horizontal","_getGestureResponseDistance","isMotionInverted","_isMotionInverted","maxDeltaX","minOffsetY","hitSlop","top","bottom","minOffsetX","maxDeltaY","left","right","gesturesEnabled","gestureDirection","I18nManager","isRTL","distance","x","value","y","gesturePosition","undefined","_prepareGestureVertical","_prepareGestureHorizontal","divide","interpolate","inputRange","outputRange","extrapolate","immediateIndex","movementDirection","movedDistance","gestureVelocity","velocityX","defaultVelocity","velocity","abs","resetDuration","goBackDuration","_computeHorizontalGestureValue","onGestureCanceled","_reset","onGestureEnd","_goBack","velocityY","_computeVerticalGestureValue","headerBackgroundTransitionPreset","includes","forBackgroundWithFade","forBackgroundWithTranslation","forBackgroundWithInactiveHidden","console","error","join","JSON","stringify","headerLayoutPreset","warn","headerTransitionPreset","headerBackTitleVisible","enabledByDefault","getComponent","SceneComponent","screenProps","getTransitionConfig","transitionConfig","lastTransitionProps","Component","StyleSheet","create","flex","flexDirection","overflow"],"sources":["C:/Users/mike/Desktop/ha/DrawingKid_Expo_20210705/node_modules/react-navigation-stack/src/views/StackView/StackViewLayout.js"],"sourcesContent":["import React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n  Dimensions,\n} from 'react-native';\nimport {\n  SceneView,\n  StackActions,\n  NavigationActions,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport { withOrientation } from '@react-navigation/native';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\n\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport HeaderStyleInterpolator from '../Header/HeaderStyleInterpolator';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport clamp from '../../utils/clamp';\nimport { supportsImprovedSpringAnimation } from '../../utils/ReactNativeFeatures';\n\nconst IPHONE_XS_HEIGHT = 812; // iPhone X and XS\nconst IPHONE_XR_HEIGHT = 896; // iPhone XR and XS Max\nconst { width: WINDOW_WIDTH, height: WINDOW_HEIGHT } = Dimensions.get('window');\nconst IS_IPHONE_X =\n  Platform.OS === 'ios' &&\n  !Platform.isPad &&\n  !Platform.isTVOS &&\n  (WINDOW_HEIGHT === IPHONE_XS_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XS_HEIGHT ||\n    WINDOW_HEIGHT === IPHONE_XR_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XR_HEIGHT);\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * Enumerate possible values for validation\n */\nconst HEADER_LAYOUT_PRESET = ['center', 'left'];\nconst HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nconst HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst USE_NATIVE_DRIVER = true;\n\nconst getDefaultHeaderHeight = isLandscape => {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else {\n    return 56;\n  }\n};\n\nclass StackViewLayout extends React.Component {\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex = null;\n\n  constructor(props) {\n    super(props);\n    this.panGestureRef = React.createRef();\n    this.gestureX = new Animated.Value(0);\n    this.gestureY = new Animated.Value(0);\n    this.positionSwitch = new Animated.Value(1);\n    if (Animated.subtract) {\n      this.gestureSwitch = Animated.subtract(1, this.positionSwitch);\n    } else {\n      this.gestureSwitch = Animated.add(\n        1,\n        Animated.multiply(-1, this.positionSwitch)\n      );\n    }\n    this.gestureEvent = Animated.event(\n      [\n        {\n          nativeEvent: {\n            translationX: this.gestureX,\n            translationY: this.gestureY,\n          },\n        },\n      ],\n      {\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }\n    );\n\n    this.state = {\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape),\n    };\n  }\n\n  _renderHeader(scene, headerMode) {\n    const { options } = scene.descriptor;\n    const { header } = options;\n\n    if (__DEV__ && typeof header === 'string') {\n      throw new Error(\n        `Invalid header value: \"${header}\". The header option must be a valid React component or null, not a string.`\n      );\n    }\n\n    if (header === null && headerMode === 'screen') {\n      return null;\n    }\n\n    // check if it's a react element\n    if (React.isValidElement(header)) {\n      return header;\n    }\n\n    // Handle the case where the header option is a function, and provide the default\n    const renderHeader = header || (props => <Header {...props} />);\n\n    let {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n      headerBackgroundInterpolator,\n    } = this._transitionConfig;\n\n    const backgroundTransitionPresetInterpolator = this._getHeaderBackgroundTransitionPreset();\n    if (backgroundTransitionPresetInterpolator) {\n      headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n    }\n\n    const { transitionProps, ...passProps } = this.props;\n\n    return (\n      <NavigationProvider value={scene.descriptor.navigation}>\n        {renderHeader({\n          ...passProps,\n          ...transitionProps,\n          position: this.position,\n          scene,\n          mode: headerMode,\n          transitionPreset: this._getHeaderTransitionPreset(),\n          layoutPreset: this._getHeaderLayoutPreset(),\n          backTitleVisible: this._getHeaderBackTitleVisible(),\n          leftInterpolator: headerLeftInterpolator,\n          titleInterpolator: headerTitleInterpolator,\n          rightInterpolator: headerRightInterpolator,\n          backgroundInterpolator: headerBackgroundInterpolator,\n        })}\n      </NavigationProvider>\n    );\n  }\n\n  _reset(resetToIndex, duration) {\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 6000,\n        damping: 100,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    } else {\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    }\n  }\n\n  _goBack(backFromIndex, duration) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n        navigation.dispatch(StackActions.completeTransition());\n      }\n    };\n\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      Animated.spring(position, {\n        toValue,\n        stiffness: 7000,\n        damping: 300,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    } else {\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  _onFloatingHeaderLayout = e => {\n    const { height } = e.nativeEvent.layout;\n    if (height !== this.state.floatingHeaderHeight) {\n      this.setState({ floatingHeaderHeight: height });\n    }\n  };\n\n  _prepareAnimated() {\n    if (this.props === this._prevProps) {\n      return;\n    }\n    this._prevProps = this.props;\n\n    this._prepareGesture();\n    this._preparePosition();\n    this._prepareTransitionConfig();\n  }\n\n  render() {\n    this._prepareAnimated();\n\n    const { transitionProps } = this.props;\n    const {\n      navigation: {\n        state: { index },\n      },\n      scenes,\n    } = transitionProps;\n\n    const headerMode = this._getHeaderMode();\n    let floatingHeader = null;\n    if (headerMode === 'float') {\n      const { scene } = transitionProps;\n      floatingHeader = (\n        <View\n          style={styles.floatingHeader}\n          pointerEvents=\"box-none\"\n          onLayout={this._onFloatingHeaderLayout}\n        >\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n\n    return (\n      <PanGestureHandler\n        {...this._gestureActivationCriteria()}\n        ref={this.panGestureRef}\n        onGestureEvent={this.gestureEvent}\n        onHandlerStateChange={this._handlePanGestureStateChange}\n        enabled={index > 0 && this._isGestureEnabled()}\n      >\n        <Animated.View\n          style={[styles.container, this._transitionConfig.containerStyle]}\n        >\n          <StackGestureContext.Provider value={this.panGestureRef}>\n            <ScreenContainer style={styles.scenes}>\n              {scenes.map(this._renderCard)}\n            </ScreenContainer>\n            {floatingHeader}\n          </StackGestureContext.Provider>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n\n  componentDidUpdate(prevProps) {\n    const { state: prevState } = prevProps.transitionProps.navigation;\n    const { state } = this.props.transitionProps.navigation;\n    if (prevState.index !== state.index) {\n      this._maybeCancelGesture();\n    }\n  }\n\n  _getGestureResponseDistance() {\n    const { scene } = this.props.transitionProps;\n    const { options } = scene.descriptor;\n    const {\n      gestureResponseDistance: userGestureResponseDistance = {},\n    } = options;\n\n    // Doesn't make sense for a response distance of 0, so this works fine\n    return this._isModal()\n      ? userGestureResponseDistance.vertical ||\n          GESTURE_RESPONSE_DISTANCE_VERTICAL\n      : userGestureResponseDistance.horizontal ||\n          GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n  }\n\n  _gestureActivationCriteria() {\n    const { layout } = this.props.transitionProps;\n    const gestureResponseDistance = this._getGestureResponseDistance();\n    const isMotionInverted = this._isMotionInverted();\n\n    if (this._isMotionVertical()) {\n      const height = layout.height.__getValue();\n\n      return {\n        maxDeltaX: 15,\n        minOffsetY: isMotionInverted ? -5 : 5,\n        hitSlop: isMotionInverted\n          ? { top: -height + gestureResponseDistance }\n          : { bottom: -height + gestureResponseDistance },\n      };\n    } else {\n      const width = layout.width.__getValue();\n      const hitSlop = -width + gestureResponseDistance;\n\n      return {\n        minOffsetX: isMotionInverted ? -5 : 5,\n        maxDeltaY: 20,\n        hitSlop: isMotionInverted ? { left: hitSlop } : { right: hitSlop },\n      };\n    }\n  }\n\n  _isGestureEnabled() {\n    const gesturesEnabled = this.props.transitionProps.scene.descriptor.options\n      .gesturesEnabled;\n    return typeof gesturesEnabled === 'boolean'\n      ? gesturesEnabled\n      : Platform.OS === 'ios';\n  }\n\n  _isMotionVertical() {\n    return this._isModal();\n  }\n\n  _isModal() {\n    return this.props.mode === 'modal';\n  }\n\n  // This only currently applies to the horizontal gesture!\n  _isMotionInverted() {\n    const {\n      transitionProps: { scene },\n    } = this.props;\n    const { options } = scene.descriptor;\n    const { gestureDirection } = options;\n\n    if (this._isModal()) {\n      return gestureDirection === 'inverted';\n    } else {\n      return typeof gestureDirection === 'string'\n        ? gestureDirection === 'inverted'\n        : I18nManager.isRTL;\n    }\n  }\n\n  _computeHorizontalGestureValue({ translationX }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    const distance = layout.width.__getValue();\n\n    const x = this._isMotionInverted() ? -1 * translationX : translationX;\n\n    const value = index - x / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  _computeVerticalGestureValue({ translationY }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    const distance = layout.height.__getValue();\n\n    const y = this._isMotionInverted() ? -1 * translationY : translationY;\n    const value = index - y / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  _handlePanGestureStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      // Gesture was cancelled! For example, some navigation state update\n      // arrived while the gesture was active that cancelled it out\n      if (this.positionSwitch.__getValue() === 1) {\n        return;\n      }\n\n      if (this._isMotionVertical()) {\n        this._handleReleaseVertical(nativeEvent);\n      } else {\n        this._handleReleaseHorizontal(nativeEvent);\n      }\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this.props.onGestureBegin && this.props.onGestureBegin();\n\n      // Switch to using gesture position\n      this.positionSwitch.setValue(0);\n\n      // By enabling the gesture switch and ignoring the position here we\n      // end up with a quick jump to the initial value and then back to the\n      // gesture. While this isn't ideal, it's preferred over preventing new\n      // gestures during the animation (all gestures should be interruptible)\n      // and we will properly fix it (interruptible and from the correct position)\n      // when we integrate reanimated. If you prefer to prevent gestures during\n      // transitions, then fork this library, comment the positionSwitch value set above,\n      // and uncomment the following two lines.\n      // if (!this.props.transitionProps.position._animation) {\n      //   this.positionSwitch.setValue(0);\n      // }\n    }\n  };\n\n  // note: this will not animated so nicely because the position is unaware\n  // of the gesturePosition, so if we are in the middle of swiping the screen away\n  // and back is programatically fired then we will reset to the initial position\n  // and animate from there\n  _maybeCancelGesture() {\n    this.positionSwitch.setValue(1);\n  }\n\n  _prepareGesture() {\n    if (!this._isGestureEnabled()) {\n      if (this.positionSwitch.__getValue() !== 1) {\n        this.positionSwitch.setValue(1);\n      }\n      this.gesturePosition = undefined;\n      return;\n    }\n\n    // We can't run the gesture if width or height layout is unavailable\n    if (\n      this.props.transitionProps.layout.width.__getValue() === 0 ||\n      this.props.transitionProps.layout.height.__getValue() === 0\n    ) {\n      return;\n    }\n\n    if (this._isMotionVertical()) {\n      this._prepareGestureVertical();\n    } else {\n      this._prepareGestureHorizontal();\n    }\n  }\n\n  _prepareGestureHorizontal() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this._isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureX, this.props.transitionProps.layout.width)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureX,\n            this.props.transitionProps.layout.width\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  _prepareGestureVertical() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this._isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureY, this.props.transitionProps.layout.height)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureY,\n            this.props.transitionProps.layout.height\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  _handleReleaseHorizontal(nativeEvent) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this._immediateIndex == null ? index : this._immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    const distance = layout.width.__getValue();\n    const movementDirection = this._isMotionInverted() ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationX;\n    const gestureVelocity = movementDirection * nativeEvent.velocityX;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = this._isMotionInverted()\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = this._isMotionInverted()\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    // Get the current position value and reset to using the statically driven\n    // (rather than gesture driven) position.\n    const value = this._computeHorizontalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n    }\n  }\n\n  _handleReleaseVertical(nativeEvent) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this._immediateIndex == null ? index : this._immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    const distance = layout.height.__getValue();\n    const isMotionInverted = this._isMotionInverted();\n    const movementDirection = isMotionInverted ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationY;\n    const gestureVelocity = movementDirection * nativeEvent.velocityY;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = isMotionInverted\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = isMotionInverted\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    const value = this._computeVerticalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this._goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this._reset(immediateIndex, resetDuration);\n    }\n  }\n\n  _getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS !== 'ios' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _getHeaderBackgroundTransitionPreset() {\n    const { headerBackgroundTransitionPreset } = this.props;\n    if (headerBackgroundTransitionPreset) {\n      if (\n        HEADER_BACKGROUND_TRANSITION_PRESET.includes(\n          headerBackgroundTransitionPreset\n        )\n      ) {\n        if (headerBackgroundTransitionPreset === 'fade') {\n          return HeaderStyleInterpolator.forBackgroundWithFade;\n        } else if (headerBackgroundTransitionPreset === 'translate') {\n          return HeaderStyleInterpolator.forBackgroundWithTranslation;\n        } else if (headerBackgroundTransitionPreset === 'toggle') {\n          return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n        }\n      } else if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerBackgroundTransitionPreset - expected one of ${HEADER_BACKGROUND_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerBackgroundTransitionPreset)}`\n        );\n      }\n    }\n\n    return null;\n  }\n\n  _getHeaderLayoutPreset() {\n    const { headerLayoutPreset } = this.props;\n    if (headerLayoutPreset) {\n      if (__DEV__) {\n        if (\n          this._getHeaderTransitionPreset() === 'uikit' &&\n          headerLayoutPreset === 'left' &&\n          Platform.OS === 'ios'\n        ) {\n          console.warn(\n            `headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'`\n          );\n        }\n      }\n      if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n        return headerLayoutPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerLayoutPreset - expected one of ${HEADER_LAYOUT_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerLayoutPreset)}`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'ios') {\n      return 'left';\n    } else {\n      return 'center';\n    }\n  }\n\n  _getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS !== 'ios' || this._getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    const { headerTransitionPreset } = this.props;\n    if (headerTransitionPreset) {\n      if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n        return headerTransitionPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerTransitionPreset - expected one of ${HEADER_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerTransitionPreset)}`\n        );\n      }\n    }\n\n    return 'fade-in-place';\n  }\n\n  _getHeaderBackTitleVisible() {\n    const { headerBackTitleVisible } = this.props;\n    const layoutPreset = this._getHeaderLayoutPreset();\n\n    // Even when we align to center on Android, people should need to opt-in to\n    // showing the back title\n    const enabledByDefault = !(\n      layoutPreset === 'left' || Platform.OS !== 'ios'\n    );\n\n    return typeof headerBackTitleVisible === 'boolean'\n      ? headerBackTitleVisible\n      : enabledByDefault;\n  }\n\n  _renderInnerScene(scene) {\n    const { navigation, getComponent } = scene.descriptor;\n    const SceneComponent = getComponent();\n\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={styles.scenes}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _prepareTransitionConfig() {\n    this._transitionConfig = TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {\n        ...this.props.transitionProps,\n        position: this.position,\n      },\n      this.props.lastTransitionProps,\n      this._isModal()\n    );\n  }\n\n  _preparePosition() {\n    if (this.gesturePosition) {\n      this.position = Animated.add(\n        Animated.multiply(\n          this.props.transitionProps.position,\n          this.positionSwitch\n        ),\n        Animated.multiply(this.gesturePosition, this.gestureSwitch)\n      );\n    } else {\n      this.position = this.props.transitionProps.position;\n    }\n  }\n\n  _renderCard = scene => {\n    const {\n      transitionProps,\n      shadowEnabled,\n      cardOverlayEnabled,\n      transparentCard,\n      cardStyle,\n    } = this.props;\n\n    const { screenInterpolator } = this._transitionConfig;\n    const style =\n      screenInterpolator &&\n      screenInterpolator({\n        ...transitionProps,\n        shadowEnabled,\n        cardOverlayEnabled,\n        position: this.position,\n        scene,\n      });\n\n    // When using a floating header, we need to add some top\n    // padding on the scene.\n    const { options } = scene.descriptor;\n    const hasHeader = options.header !== null;\n    const headerMode = this._getHeaderMode();\n    let paddingTopStyle;\n    if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n      paddingTopStyle = { paddingTop: this.state.floatingHeaderHeight };\n    }\n\n    return (\n      <Card\n        {...transitionProps}\n        key={`card_${scene.key}`}\n        position={this.position}\n        realPosition={transitionProps.position}\n        animatedStyle={style}\n        transparent={transparentCard}\n        style={[paddingTopStyle, cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n    overflow: 'hidden',\n  },\n  scenes: {\n    flex: 1,\n  },\n  floatingHeader: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n  },\n});\n\nexport default withOrientation(StackViewLayout);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}