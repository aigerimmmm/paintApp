{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  var nextRoutes = nextState.routes;\n\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    var prevRoutes = prevState.routes;\n\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n\n    prevRoutes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      });\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread(_objectSpread({}, scene), {}, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n\n  return scenes;\n}","map":{"version":3,"names":["invariant","shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"sources":["C:/Users/mike/Desktop/ha/DrawingKid_Expo_20210705/node_modules/react-navigation-stack/src/views/ScenesReducer.js"],"sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes,\n  nextState,\n  prevState,\n  descriptors\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n        'another route!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(\n    activeScenesCount === 1,\n    'there should always be only one scene active, not %s.',\n    activeScenesCount\n  );\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}